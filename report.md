# #4 Comparative Analysis of Binary Search Trees and Red-Black Trees

## Introduction
This report presents a comparative analysis between a standard Binary Search Tree (BST) and a Red-Black Tree (RBT), focusing on their performance in insertion, search, and deletion operations. The study examines both skewed and non-skewed data across different sizes to evaluate the operational efficiency and structural properties of these tree types.

## Methodology
### Experimental Setup
- **Trees Analyzed**: Standard BST and RBT.
- **Data Sets**: Skewed and non-skewed data across sizes (200, 400, 800, 1600, 3200).
- **Operations Measured**: Insertion, search, and deletion.
- **Performance Metrics**: Average time taken for operations, average height of the trees.
- **Tools Used**: Execution timers to measure operation times accurately.

### Data Generation
- **Skewed Data**: Generated by inserting nodes in a specific order to simulate real-world uneven data distribution.
- **Non-Skewed Data**: Randomly generated to ensure an even distribution.


## Results and Analysis

**The results of the experiment can be found in the root of the project, in a file called tree_results.md.**

**The results can be summarized as follows:**

#### Skewed Data
- **Insertion Time and Height:** The Red-Black Tree (RBT) significantly outperforms the Binary Search Tree (BST) in terms of insertion time as the data size increases. This is evident from the drastic difference in insertion times; for instance, at size 3200, the BST's insertion time spikes to 0.246974 ms compared to RBT's 0.002025 ms. The height of the BST rapidly approaches the total number of nodes, reflecting a degradation towards a linked-list structure in skewed scenarios. Conversely, the RBT maintains a logarithmic height growth, highlighting its effective balancing mechanism.

- **Search and Deletion Time:** The search and deletion times in BSTs exhibit a linear growth with increasing data size, becoming inefficient for skewed data handling. The RBT showcases its strength in these operations with significantly lower times, benefiting from its balanced structure. For example, at size 3200, the BST's search time is 0.435898 ms versus RBT's 0.002879 ms, and deletion time is 0.246229 ms for BST against RBT's 0.004131 ms.

#### Non-Skewed Data
- **Insertion Time and Height:** Both trees show comparable insertion times, but RBT consistently maintains a lower average height, reinforcing its advantage in maintaining balance. As the data size grows, this advantage becomes more pronounced, ensuring efficient depth management for optimal operation times.

- **Search and Deletion Time:** Performance in search and deletion operations is similar between the two tree types, suggesting that for non-skewed (evenly distributed) data, the impact of tree balancing is less significant. However, RBT slightly edges out with better times, especially in deletion operations at larger sizes, hinting at its superior efficiency in maintaining structure post-operation.

## Comparative Insights
- **Efficiency in Skewed Data:** The RBT demonstrates a clear advantage in handling skewed data, with significantly better performance in insertion, search, and deletion operations. Its self-balancing feature prevents the degradation seen in BSTs, where structure tends towards a linked-list, impairing operational efficiency.

- **Performance in Non-Skewed Data:** While both trees perform similarly in non-skewed scenarios, RBT's inherent balancing mechanism ensures a consistently lower tree height and marginally better operation times. This indicates that RBTs offer a more reliable performance across varied data distributions.

- **Structural Stability:** RBTs exhibit superior structural stability across both skewed and non-skewed datasets. This stability not only enhances operation times but also ensures predictability in performance, an attribute critical for real-world applications.

## Conclusion
This analysis underscores the critical role of tree balancing in data structures, particularly in scenarios involving skewed data. The BST, while adequate for non-skewed data, shows pronounced inefficiencies as data becomes more skewed. The RBT, with its self-balancing properties, not only outperforms the BST in skewed data scenarios but also maintains consistent efficiency across different data distributions. This experiment highlights the RBT's superior balancing mechanism as a pivotal factor in its performance, making it a more versatile and reliable choice for real-world applications requiring efficient data manipulation and retrieval operations.


#
# #6 Hash Function Analysis for Vehicle Registration

## Introduction
This section analyzes the effectiveness of a hash function used in a hash table for storing vehicle information, focusing on registration numbers. The study evaluates conflict frequencies in relation to table capacities and vehicle counts.

## Methodology
### Experimental Setup
- **Hash Table Capacities**: Evaluated at 10, 20, 40, 80, 160.
- **Vehicle Counts**: 50, 100, 200, 400, 800 vehicles.
- **Metrics Measured**:
  - Average Initial Conflicts: Conflicts before probing.
  - Average Probing Conflicts: Conflicts during probing.
  - Average Total Conflicts: Sum of initial and probing conflicts.

### Hash Function
- **Function Design**: Based on vehicle registration numbers.
- **Probing Strategy**: Specific strategy used for resolving conflicts (e.g., quadratic probing).


## Results and Analysis

**The results of the experiment can be found in the root of the project, in a file called vehicles_results.md.**

**The results can be summarized as follows:**

### Impact of Table Capacity on Conflicts
The experimental results underscore a clear relationship between table capacity and conflict frequency. At **lower capacities (10, 20)**, the hash table experiences a significant number of conflicts, particularly in probing, as seen with an initial capacity of 10 yielding an average total of 912.9 conflicts for 50 vehicles, escalating sharply with higher vehicle counts. This trend reflects the limited space causing frequent collisions and necessitating extensive probing.

As table capacity increases to **medium levels (40, 80)**, there's a notable decrease in both initial and probing conflicts. For instance, at a capacity of 80, the transition is dramatic, with total conflicts dropping to 13.7 for 50 vehicles, illustrating improved efficiency in data distribution and conflict resolution.

The **highest capacity (160)** further diminishes the conflict rates, with total conflicts for 50 vehicles at a mere 11.0, demonstrating the most effective conflict management across all capacities evaluated.

### Impact of Vehicle Count on Conflicts
Increasing the vehicle count consistently exacerbates conflict frequencies across all table capacities. However, the extent of this effect is mitigated as the capacity expands. This pattern is evident in how total conflicts rise with each increment in vehicle count, highlighting the hash function's challenge in maintaining efficiency with larger datasets.

### Hash Function Efficiency
The efficiency of the hash function, as reflected through initial and probing conflicts, shows a significant dependency on the table's initial capacity and the dataset size. Higher capacities tend to distribute data more evenly, reducing the likelihood of initial conflicts and easing the probing process.

## Comparative Insights
- **Capacity vs. Dataset Size:** The experiment highlight that larger table capacities significantly mitigate conflict frequencies, underlining the critical balance between table size and dataset size for optimizing hash table performance. Larger capacities provide more "room" for elements, thereby reducing the chances for collisions and the subsequent need for extensive probing.
  
- **Probing Strategy Efficiency:** The reduction in probing conflicts at higher capacities suggests that the efficiency of the probing strategy is closely tied to the available space in the hash table. An effective probing strategy, particularly quadratic probing, is essential for managing conflicts, especially as vehicle counts increase. This strategy appears to work best when the table is not overly congested, as seen in the stark contrast between total conflicts at lower vs. higher capacities.

## Conclusion
This analysis reveals that the hash function's performance for vehicle registration numbers is influenced by both the hash table's initial capacity and the total number of vehicles stored. High table capacities significantly enhance the hash function's efficiency, showcasing fewer conflicts and better management of vehicle registrations. This teaches us that for something like storing vehicle information, planning ahead and preparing for the amount of data and selecting a good method to resolve conflicts are key steps to ensure everything runs smoothly and efficiently.